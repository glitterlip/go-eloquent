// Code generated by mockery v2.10.0. DO NOT EDIT.

package mocks

import (
	"github.com/glitterlip/goeloquent"
	mock "github.com/stretchr/testify/mock"

	sql "database/sql"
)

// IConnection is an autogenerated mock type for the IConnection type
type IConnection struct {
	mock.Mock
}

// AffectingStatement provides a mock function with given fields: query, bindings
func (_m *IConnection) AffectingStatement(query string, bindings []interface{}) (Result, error) {
	ret := _m.Called(query, bindings)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}) Result); ok {
		r0 = rf(query, bindings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}) error); ok {
		r1 = rf(query, bindings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: query, bindings
func (_m *IConnection) Delete(query string, bindings []interface{}) (Result, error) {
	ret := _m.Called(query, bindings)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}) Result); ok {
		r0 = rf(query, bindings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}) error); ok {
		r1 = rf(query, bindings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: query, bindings
func (_m *IConnection) Insert(query string, bindings []interface{}) (Result, error) {
	ret := _m.Called(query, bindings)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}) Result); ok {
		r0 = rf(query, bindings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}) error); ok {
		r1 = rf(query, bindings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Select provides a mock function with given fields: query, bindings, dest
func (_m *IConnection) Select(query string, bindings []interface{}, dest interface{}) (Result, error) {
	ret := _m.Called(query, bindings, dest)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}, interface{}) Result); ok {
		r0 = rf(query, bindings, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}, interface{}) error); ok {
		r1 = rf(query, bindings, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Statement provides a mock function with given fields: query, bindings
func (_m *IConnection) Statement(query string, bindings []interface{}) (Result, error) {
	ret := _m.Called(query, bindings)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}) Result); ok {
		r0 = rf(query, bindings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}) error); ok {
		r1 = rf(query, bindings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Table provides a mock function with given fields: tableName
func (_m *IConnection) Table(tableName string) *goeloquent.Builder {
	ret := _m.Called(tableName)

	var r0 *goeloquent.Builder
	if rf, ok := ret.Get(0).(func(string) *goeloquent.Builder); ok {
		r0 = rf(tableName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goeloquent.Builder)
		}
	}
	r0.Components = make(map[string]struct{})
	r0.Bindings = make(map[string][]interface{})
	r0.Connection = &goeloquent.Connection{
		DB:             &sql.DB{},
		Config:         nil,
		ConnectionName: "",
	}
	r0.From(tableName)
	r0.Grammar = &goeloquent.MysqlGrammar{
		Prefix:  "",
		Builder: r0,
	}
	return r0
}

// Update provides a mock function with given fields: query, bindings
func (_m *IConnection) Update(query string, bindings []interface{}) (Result, error) {
	ret := _m.Called(query, bindings)

	var r0 Result
	if rf, ok := ret.Get(0).(func(string, []interface{}) Result); ok {
		r0 = rf(query, bindings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Result)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []interface{}) error); ok {
		r1 = rf(query, bindings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
